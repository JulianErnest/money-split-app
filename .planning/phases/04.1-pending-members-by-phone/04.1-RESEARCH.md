# Phase 4.1: Pending Members by Phone - Research

**Researched:** 2026-02-18
**Domain:** Supabase schema design, PostgreSQL triggers, pending/placeholder user patterns
**Confidence:** HIGH

## Summary

This phase introduces a "pending member" concept: users who are added to a group by phone number before they have signed up. The core challenge is that the current schema tightly couples everything to `auth.users` via foreign keys -- `group_members.user_id`, `expense_splits.user_id`, and `expenses.paid_by` all reference `public.users(id)` which itself references `auth.users(id)`. Pending members do not exist in `auth.users`, so they cannot be stored in the current `group_members` or `expense_splits` tables without schema changes.

The recommended approach is to introduce a `pending_members` table that stores phone-number-identified placeholders, then use a PostgreSQL trigger on `auth.users` to auto-link when the person signs up. The critical design decision is whether pending members get their own parallel table or are merged into existing tables with nullable foreign keys. The parallel table approach is cleaner because it avoids weakening existing FK constraints and keeps RLS policies unchanged for real users.

The auto-linking trigger fires on `auth.users` INSERT (when someone signs up), looks up any pending members with a matching phone number, creates proper `group_members` entries, updates `expense_splits` to point to the real user, and deletes the pending records. This must be transactional to avoid partial state.

**Primary recommendation:** Create a `pending_members` table keyed by phone number, a parallel `pending_expense_splits` column approach using the pending_member_id, and an `auth.users` INSERT trigger that atomically claims all pending records for the new user.

## Standard Stack

No new libraries needed. This phase is entirely backend schema + trigger logic with minor frontend modifications.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Supabase (Postgres) | existing | Database schema, triggers, RPC functions | Already in stack |
| Expo Router | existing | Navigation for add-member flow | Already in stack |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| (none new) | - | - | - |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Separate `pending_members` table | Nullable FK in `group_members` | Nullable FK weakens data integrity, complicates RLS, breaks existing queries |
| DB trigger for auto-link | Client-side check on login | Trigger is atomic and reliable; client-side is racy and could miss edge cases |
| `pending_expense_splits` referencing pending_member_id | Storing phone string in expense_splits | Phone string approach breaks the FK pattern and complicates balance queries |

## Architecture Patterns

### Database Schema Design

```
-- NEW TABLES / COLUMNS --

pending_members
├── id              uuid PK (gen_random_uuid)
├── group_id        uuid FK -> groups(id) ON DELETE CASCADE
├── phone_number    text NOT NULL (E.164 format: +639XXXXXXXXX)
├── added_by        uuid FK -> users(id) NOT NULL
├── display_label   text (optional friendly label like "Juan's phone")
├── created_at      timestamptz
└── UNIQUE(group_id, phone_number)  -- one pending entry per phone per group

-- expense_splits gets a nullable pending_member_id column --
expense_splits (ALTERED)
├── ... existing columns ...
├── user_id         uuid FK -> users(id)  -- NOW NULLABLE for pending splits
└── pending_member_id  uuid FK -> pending_members(id) -- NULLABLE, one of user_id or pending_member_id must be set
    CHECK (user_id IS NOT NULL OR pending_member_id IS NOT NULL)
    UNIQUE changed to: UNIQUE(expense_id, user_id) WHERE user_id IS NOT NULL
                        UNIQUE(expense_id, pending_member_id) WHERE pending_member_id IS NOT NULL
```

**Alternative (Recommended Simpler Approach):** Instead of altering `expense_splits`, keep `expense_splits.user_id` pointing to real users only, and add a separate reference approach:

```
pending_members
├── id              uuid PK
├── group_id        uuid FK -> groups(id) ON DELETE CASCADE
├── phone_number    text NOT NULL
├── added_by        uuid FK -> users(id) NOT NULL
├── claimed_by      uuid FK -> users(id) -- set when user signs up
├── created_at      timestamptz
└── UNIQUE(group_id, phone_number)

-- Use pending_member_id in expense_splits alongside user_id
expense_splits (ALTERED)
├── ... existing columns ...
├── user_id         uuid FK -> users(id) -- MAKE NULLABLE
└── pending_member_id  uuid FK -> pending_members(id) -- NULLABLE
    CHECK (num_nonnulls(user_id, pending_member_id) = 1)
```

### Pattern 1: Pending Member Table with Phone-Based Lookup

**What:** A dedicated table for members who exist only as phone numbers, not yet linked to auth accounts.
**When to use:** Always, for this feature.
**Key design points:**
- Phone numbers stored in E.164 format (`+639XXXXXXXXX`) matching the auth phone format
- `UNIQUE(group_id, phone_number)` prevents duplicate pending entries
- `added_by` tracks who invited the pending member
- No FK to `auth.users` -- that is the whole point

### Pattern 2: Auto-Link via PostgreSQL Trigger on auth.users

**What:** When a new user signs up via phone OTP, a trigger fires that checks for any `pending_members` rows matching their phone number and converts them to real memberships.
**When to use:** On every new user signup.

**Trigger flow:**
1. New row inserted into `auth.users` (Supabase auth handles this)
2. Trigger function fires AFTER INSERT
3. Function reads `NEW.phone` to get the phone number
4. Looks up all `pending_members` where `phone_number = NEW.phone`
5. For each match:
   a. INSERT into `group_members` (group_id, user_id=NEW.id)
   b. UPDATE `expense_splits` SET user_id = NEW.id WHERE pending_member_id = pending_member.id
   c. DELETE the pending_members row (or SET claimed_by = NEW.id)
6. Also INSERT into `public.users` if the standard profile-creation trigger should handle that

**Critical:** The trigger function must use `SECURITY DEFINER` and `SET search_path = public` to have proper permissions, since `supabase_auth_admin` has limited access.

### Pattern 3: Unified Member Interface on Frontend

**What:** The frontend treats real members and pending members as a single list, with a `status` flag.
**When to use:** In group detail, payer selection, and split selection.

```typescript
interface GroupMember {
  id: string;            // user.id for real members, pending_members.id for pending
  display_name: string;  // user.display_name or formatted phone for pending
  avatar_url: string | null;
  isPending: boolean;    // true for pending members
  phone_number?: string; // only for pending members
}
```

### Anti-Patterns to Avoid
- **Creating fake auth.users entries:** Never insert placeholder rows into `auth.users` -- this corrupts the auth system and creates phantom accounts that could conflict with real signups.
- **Storing pending members only client-side:** Must be in the database so all group members see them and expenses persist across sessions.
- **Using phone number strings as IDs in expense_splits:** Breaks the UUID-based FK pattern and makes balance queries unreliable.
- **Letting pending members be "payers":** A pending member cannot have paid for an expense because they have not confirmed their identity. Only real members should be selectable as payers.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Phone number validation | Custom regex | Reuse existing `+63` + 10-digit pattern from phone.tsx | Already validated in auth flow |
| Auto-linking on signup | Client-side polling/check | PostgreSQL AFTER INSERT trigger on auth.users | Atomic, reliable, runs before user sees app |
| Duplicate prevention | Application-level checks | UNIQUE(group_id, phone_number) DB constraint | Race-condition proof |
| Transaction safety for claim | Manual multi-query | Single PL/pgSQL function with SECURITY DEFINER | Atomic, no partial state |

**Key insight:** The auto-link trigger is the single most critical piece. If done as client-side logic, there are race conditions where a user could sign up and not see their pending debts. The DB trigger guarantees atomicity.

## Common Pitfalls

### Pitfall 1: Phone Number Format Mismatch
**What goes wrong:** Pending member phone stored as `09171234567` but auth.users stores `+639171234567`, so trigger match fails.
**Why it happens:** Inconsistent normalization between the "add member" input and Supabase's auth phone storage.
**How to avoid:** Always store phone numbers in E.164 format (`+63XXXXXXXXX`). Normalize on input: strip spaces, ensure +63 prefix. The existing phone.tsx already sends `+63${rawDigits}` to Supabase auth.
**Warning signs:** Pending members never auto-link after signup.

### Pitfall 2: Trigger Permission Errors
**What goes wrong:** Trigger function cannot INSERT into `public.group_members` or UPDATE `public.expense_splits`.
**Why it happens:** The trigger runs as `supabase_auth_admin` which has limited permissions outside `auth` schema.
**How to avoid:** Use `SECURITY DEFINER` on the trigger function, created by the `postgres` role. Set `search_path = public` explicitly.
**Warning signs:** Signup succeeds but no group memberships appear; check Supabase logs for permission denied errors.

### Pitfall 3: Trigger Failure Blocks Signups
**What goes wrong:** A bug in the auto-link trigger function causes ALL new user signups to fail.
**Why it happens:** AFTER INSERT triggers that raise exceptions will roll back the entire transaction, including the auth.users INSERT.
**How to avoid:** Wrap trigger logic in BEGIN...EXCEPTION block that catches errors and logs them rather than re-raising. Never let the auto-link failure prevent signup.
**Warning signs:** New users cannot sign up at all; Supabase auth returns 500 errors.

### Pitfall 4: RLS Policy Gaps for Pending Members
**What goes wrong:** Group members cannot see pending members, or pending member expense splits are invisible.
**Why it happens:** Existing RLS policies only check `group_members.user_id = auth.uid()`. Pending members are not in `group_members`, so their data is not visible through existing policies.
**How to avoid:** Add RLS policies for the `pending_members` table. Also update `expense_splits` RLS if the table is altered to include `pending_member_id`.
**Warning signs:** Empty member lists or missing expense split entries.

### Pitfall 5: Duplicate Group Membership on Claim
**What goes wrong:** User who was a pending member AND also joined via invite link ends up with duplicate `group_members` entries.
**Why it happens:** Trigger creates `group_members` row, but user already joined via invite before pending claim ran.
**How to avoid:** Use `ON CONFLICT (group_id, user_id) DO NOTHING` when inserting into `group_members` during the claim process.
**Warning signs:** Duplicate key errors in logs; member appears twice in group.

### Pitfall 6: Altering expense_splits Breaks Existing create_expense RPC
**What goes wrong:** The `create_expense` RPC inserts into `expense_splits` with only `user_id`. After schema change adding `pending_member_id`, the CHECK constraint or NOT NULL constraint fails.
**How to avoid:** When altering `expense_splits`, ensure:
1. `user_id` becomes NULLABLE (was implicitly NOT NULL via FK)
2. Add CHECK constraint: `num_nonnulls(user_id, pending_member_id) = 1`
3. Update `create_expense` RPC to accept pending member splits
4. The existing RPC must still work for real-user-only splits
**Warning signs:** Existing expense creation breaks after migration.

## Code Examples

### Migration: Create pending_members table

```sql
-- Source: Custom for this project, pattern verified via Supabase docs
-- supabase/migrations/00005_pending_members.sql

-- Pending members: phone-number-identified placeholders for users not yet signed up
create table public.pending_members (
  id uuid primary key default gen_random_uuid(),
  group_id uuid references public.groups(id) on delete cascade not null,
  phone_number text not null,  -- E.164 format: +639XXXXXXXXX
  added_by uuid references public.users(id) not null,
  created_at timestamptz default now() not null,
  unique(group_id, phone_number)
);

alter table public.pending_members enable row level security;

-- Members of the group can view pending members in their groups
create policy "Members can view pending members"
  on public.pending_members for select
  using (group_id in (select public.get_user_group_ids()));

-- Members can add pending members to their groups
create policy "Members can add pending members"
  on public.pending_members for insert
  to authenticated
  with check (
    group_id in (select public.get_user_group_ids())
    and (select auth.uid()) = added_by
  );

-- Members can delete pending members from their groups
create policy "Members can remove pending members"
  on public.pending_members for delete
  using (group_id in (select public.get_user_group_ids()));

-- Index for phone number lookup during auto-link
create index idx_pending_members_phone on public.pending_members(phone_number);
create index idx_pending_members_group_id on public.pending_members(group_id);
```

### Migration: Alter expense_splits for pending member support

```sql
-- Allow expense_splits to reference pending members
alter table public.expense_splits
  alter column user_id drop not null;

alter table public.expense_splits
  add column pending_member_id uuid references public.pending_members(id) on delete set null;

-- Ensure exactly one of user_id or pending_member_id is set
alter table public.expense_splits
  add constraint expense_splits_member_check
  check (num_nonnulls(user_id, pending_member_id) = 1);

-- Drop the old unique constraint and create conditional ones
alter table public.expense_splits
  drop constraint if exists expense_splits_expense_id_user_id_key;

create unique index expense_splits_expense_user_unique
  on public.expense_splits(expense_id, user_id)
  where user_id is not null;

create unique index expense_splits_expense_pending_unique
  on public.expense_splits(expense_id, pending_member_id)
  where pending_member_id is not null;

-- Index for claim lookups
create index idx_expense_splits_pending_member
  on public.expense_splits(pending_member_id)
  where pending_member_id is not null;
```

### Migration: Auto-link trigger on auth.users

```sql
-- Source: Pattern from https://supabase.com/docs/guides/auth/managing-user-data
-- Adapted for pending member auto-linking

create or replace function public.handle_pending_member_claim()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  pending record;
begin
  -- Look up all pending members matching this phone number
  for pending in
    select id, group_id from pending_members
    where phone_number = new.phone
  loop
    -- Add user to the group (idempotent)
    insert into group_members (group_id, user_id)
    values (pending.group_id, new.id)
    on conflict (group_id, user_id) do nothing;

    -- Transfer expense splits from pending to real user
    update expense_splits
    set user_id = new.id, pending_member_id = null
    where pending_member_id = pending.id;

    -- Remove the pending member entry
    delete from pending_members where id = pending.id;
  end loop;

  return new;
exception
  when others then
    -- Log but do not block signup
    raise warning 'pending_member_claim failed for phone %: %', new.phone, sqlerrm;
    return new;
end;
$$;

-- Fire after insert on auth.users (when someone signs up)
create trigger on_auth_user_created_claim_pending
  after insert on auth.users
  for each row
  execute function public.handle_pending_member_claim();
```

### RPC: Add pending member to group

```sql
create or replace function public.add_pending_member(
  p_group_id uuid,
  p_phone_number text  -- Expected: +639XXXXXXXXX
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  current_user_id uuid := auth.uid();
  existing_user_id uuid;
  new_pending_id uuid;
begin
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  -- Verify caller is a member of the group
  if not exists (
    select 1 from group_members
    where group_id = p_group_id and user_id = current_user_id
  ) then
    raise exception 'Not a member of this group';
  end if;

  -- Check if a user with this phone already exists and is already a member
  select u.id into existing_user_id
  from users u
  where u.phone_number = p_phone_number;

  if existing_user_id is not null then
    -- User exists -- check if already a group member
    if exists (
      select 1 from group_members
      where group_id = p_group_id and user_id = existing_user_id
    ) then
      raise exception 'This person is already a member of this group';
    end if;

    -- User exists but not in group -- add them directly
    insert into group_members (group_id, user_id)
    values (p_group_id, existing_user_id);

    return existing_user_id;
  end if;

  -- Check if already a pending member
  if exists (
    select 1 from pending_members
    where group_id = p_group_id and phone_number = p_phone_number
  ) then
    raise exception 'This phone number is already pending in this group';
  end if;

  -- Create pending member
  insert into pending_members (group_id, phone_number, added_by)
  values (p_group_id, p_phone_number, current_user_id)
  returning id into new_pending_id;

  return new_pending_id;
end;
$$;
```

### Updated create_expense RPC (must handle pending splits)

```sql
-- Update create_expense to accept pending_member_id in splits
create or replace function public.create_expense(
  p_group_id uuid,
  p_description text,
  p_amount numeric(10,2),
  p_paid_by uuid,
  p_split_type text,
  p_splits jsonb  -- array of { "user_id": uuid | null, "pending_member_id": uuid | null, "amount": numeric }
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  new_expense_id uuid;
  current_user_id uuid := auth.uid();
  split_record jsonb;
  splits_total numeric(10,2) := 0;
begin
  -- Auth check
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  -- Verify caller is a member of the group
  if not exists (
    select 1 from group_members
    where group_id = p_group_id and user_id = current_user_id
  ) then
    raise exception 'Not a member of this group';
  end if;

  -- Verify payer is a real member of the group (not pending)
  if not exists (
    select 1 from group_members
    where group_id = p_group_id and user_id = p_paid_by
  ) then
    raise exception 'Payer is not a member of this group';
  end if;

  -- Validate split type
  if p_split_type not in ('equal', 'custom') then
    raise exception 'Invalid split type: must be equal or custom';
  end if;

  -- Validate splits sum to total amount
  for split_record in select * from jsonb_array_elements(p_splits)
  loop
    splits_total := splits_total + (split_record->>'amount')::numeric;
  end loop;

  if splits_total != p_amount then
    raise exception 'Splits do not sum to total amount: expected %, got %', p_amount, splits_total;
  end if;

  -- Insert expense
  insert into expenses (group_id, description, amount, paid_by, split_type, created_by)
  values (p_group_id, p_description, p_amount, p_paid_by, p_split_type, current_user_id)
  returning id into new_expense_id;

  -- Insert splits from jsonb array (now supports pending_member_id)
  insert into expense_splits (expense_id, user_id, pending_member_id, amount)
  select
    new_expense_id,
    case when elem->>'user_id' is not null and elem->>'user_id' != ''
      then (elem->>'user_id')::uuid else null end,
    case when elem->>'pending_member_id' is not null and elem->>'pending_member_id' != ''
      then (elem->>'pending_member_id')::uuid else null end,
    (elem->>'amount')::numeric
  from jsonb_array_elements(p_splits) as elem;

  return new_expense_id;
end;
$$;
```

### Frontend: Unified member type

```typescript
// lib/types.ts or within component
interface GroupMember {
  id: string;              // user.id for real, pending_members.id for pending
  display_name: string;    // user.display_name or "+63 9XX XXX XXXX" for pending
  avatar_url: string | null;
  isPending: boolean;
}

// Fetching combined member list
async function fetchAllMembers(groupId: string): Promise<GroupMember[]> {
  const [realResult, pendingResult] = await Promise.all([
    supabase
      .from('group_members')
      .select('user_id, users (id, display_name, avatar_url)')
      .eq('group_id', groupId),
    supabase
      .from('pending_members')
      .select('id, phone_number')
      .eq('group_id', groupId),
  ]);

  const realMembers: GroupMember[] = (realResult.data ?? []).map((row: any) => ({
    id: row.users.id,
    display_name: row.users.display_name || 'Unknown',
    avatar_url: row.users.avatar_url,
    isPending: false,
  }));

  const pendingMembers: GroupMember[] = (pendingResult.data ?? []).map((row: any) => ({
    id: row.id,
    display_name: formatPhoneDisplay(row.phone_number),
    avatar_url: null,
    isPending: true,
  }));

  return [...realMembers, ...pendingMembers];
}
```

### Frontend: Phone input for adding pending member

```typescript
// Reuse the same +63 prefix pattern from phone.tsx auth screen
// Validate: exactly 10 digits after +63, starting with 9
function isValidPHPhone(digits: string): boolean {
  return /^9\d{9}$/.test(digits);
}

function formatPhoneDisplay(e164: string): string {
  // +639171234567 -> "+63 917 123 4567"
  const digits = e164.replace('+63', '');
  if (digits.length === 10) {
    return `+63 ${digits.slice(0, 3)} ${digits.slice(3, 6)} ${digits.slice(6)}`;
  }
  return e164;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Require all users to sign up first | Pending/placeholder member pattern | Common in Splitwise-like apps | Users can split expenses immediately without waiting for friends to install |
| Client-side account linking | Database trigger on auth.users | Supabase best practice | Atomic, reliable, no race conditions |

**Key pattern from similar apps (Splitwise, Tricount):** These apps all support adding members by contact info before they sign up. The standard approach is a placeholder record that gets "claimed" on signup. Splitwise uses email-based placeholders; this app uses phone-based.

## Open Questions

1. **Should pending members be able to be the "payer" of an expense?**
   - What we know: Logically a pending member could have paid (e.g., "My friend Juan paid for dinner but isn't on the app yet")
   - What's unclear: The `expenses.paid_by` column references `users(id)` -- allowing pending payers would require making this nullable or adding `pending_paid_by`
   - Recommendation: For simplicity in Stage 1, restrict payers to real members only. Document this limitation. Add pending-as-payer in a future iteration if needed.

2. **What happens if a user is added as pending to multiple groups?**
   - What we know: The `UNIQUE(group_id, phone_number)` constraint handles per-group uniqueness. The trigger loops over ALL matching pending_members across all groups.
   - What's unclear: Nothing -- the trigger handles this correctly by design.
   - Recommendation: No action needed; the trigger loop handles multi-group claims.

3. **Should there be a notification/SMS sent to pending members?**
   - What we know: Not in scope for this phase (would require SMS integration like Twilio)
   - Recommendation: Out of scope. The invite link sharing feature already exists for notifying friends.

4. **How to handle the `public.users` row creation for claimed users?**
   - What we know: Currently, `public.users` rows are created in profile-setup.tsx via upsert. There is no trigger creating them automatically on auth signup.
   - What's unclear: The auto-link trigger needs the user to exist in `public.users` for the `group_members` FK. But `public.users` is only created during profile setup.
   - Recommendation: The auto-link trigger should ALSO create the `public.users` row (with phone_number and null display_name) so that `group_members` FK succeeds. The profile-setup upsert will fill in display_name later. Alternatively, create the `public.users` row in a separate `on_auth_user_created` trigger that fires BEFORE the pending claim trigger (use trigger ordering or combine into one function).

## Sources

### Primary (HIGH confidence)
- Supabase docs: [Managing User Data / Triggers](https://supabase.com/docs/guides/auth/managing-user-data) - trigger pattern on auth.users, SECURITY DEFINER requirement
- Supabase docs: [PostgreSQL Triggers](https://supabase.com/docs/guides/database/postgres/triggers) - trigger syntax, NEW variable access
- Existing codebase: All 4 migration files, database.types.ts, group detail screen, add-expense screen, auth flow

### Secondary (MEDIUM confidence)
- [Supabase Discussion #306](https://github.com/orgs/supabase/discussions/306) - Community patterns for auth.users triggers
- [Supabase Discussion #34518](https://github.com/orgs/supabase/discussions/34518) - Permission issues with auth.users triggers

### Tertiary (LOW confidence)
- General "pending member" pattern inferred from Splitwise/Tricount app behavior (not documented source)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries, just Supabase schema changes
- Architecture: HIGH - Pattern is well-established (trigger on auth.users, placeholder table)
- Pitfalls: HIGH - Derived from direct codebase analysis and Supabase documentation
- Auto-link trigger: MEDIUM - Pattern verified in docs but `NEW.phone` field access needs validation during implementation

**Research date:** 2026-02-18
**Valid until:** 2026-03-18 (stable Supabase patterns)
