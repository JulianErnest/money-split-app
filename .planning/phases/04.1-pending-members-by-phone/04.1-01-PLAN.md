---
phase: 04.1-pending-members-by-phone
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00005_pending_members.sql
  - supabase/migrations/00006_update_expense_splits_pending.sql
  - supabase/migrations/00007_auto_link_trigger.sql
  - supabase/migrations/00008_pending_member_rpcs.sql
autonomous: true

must_haves:
  truths:
    - "pending_members table exists with group_id, phone_number, added_by columns"
    - "expense_splits allows nullable user_id with pending_member_id alternative"
    - "Auto-link trigger fires on auth.users INSERT and claims pending members"
    - "add_pending_member RPC validates group membership, checks for existing user, creates pending record"
    - "create_expense RPC accepts pending_member_id in splits"
  artifacts:
    - path: "supabase/migrations/00005_pending_members.sql"
      provides: "pending_members table with RLS policies"
      contains: "create table public.pending_members"
    - path: "supabase/migrations/00006_update_expense_splits_pending.sql"
      provides: "expense_splits schema changes for pending member support"
      contains: "pending_member_id"
    - path: "supabase/migrations/00007_auto_link_trigger.sql"
      provides: "Auto-link trigger on auth.users"
      contains: "handle_pending_member_claim"
    - path: "supabase/migrations/00008_pending_member_rpcs.sql"
      provides: "add_pending_member and updated create_expense RPCs"
      contains: "add_pending_member"
  key_links:
    - from: "supabase/migrations/00007_auto_link_trigger.sql"
      to: "pending_members table"
      via: "trigger on auth.users INSERT"
      pattern: "after insert on auth.users"
    - from: "supabase/migrations/00008_pending_member_rpcs.sql"
      to: "expense_splits"
      via: "create_expense RPC inserts pending_member_id"
      pattern: "pending_member_id"
---

<objective>
Create the database foundation for pending members: the pending_members table, expense_splits schema changes, auto-link trigger, and RPC functions.

Purpose: All frontend features depend on these tables, constraints, triggers, and RPCs existing. This is the foundation layer.
Output: 4 migration files that can be applied to Supabase to enable pending member support.
</objective>

<execution_context>
@/Users/julianernestcamello/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianernestcamello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04.1-pending-members-by-phone/04.1-RESEARCH.md
@supabase/migrations/00001_initial_schema.sql
@supabase/migrations/00004_create_expense_rpc.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pending_members table and alter expense_splits</name>
  <files>
    supabase/migrations/00005_pending_members.sql
    supabase/migrations/00006_update_expense_splits_pending.sql
  </files>
  <action>
    Create migration 00005_pending_members.sql:
    - Create `public.pending_members` table with columns: id (uuid PK, gen_random_uuid), group_id (FK groups, ON DELETE CASCADE, NOT NULL), phone_number (text NOT NULL, E.164 format), added_by (FK users, NOT NULL), created_at (timestamptz default now)
    - Add UNIQUE(group_id, phone_number) constraint
    - Enable RLS
    - Add SELECT policy: members can view pending members in their groups (use `get_user_group_ids()` helper that already exists from migration 00002)
    - Add INSERT policy: authenticated users can add pending members to groups they belong to, with `added_by = auth.uid()` check
    - Add DELETE policy: members can remove pending members from their groups
    - Add indexes on phone_number and group_id

    Create migration 00006_update_expense_splits_pending.sql:
    - ALTER expense_splits: make user_id NULLABLE (drop NOT NULL)
    - ADD column pending_member_id (uuid FK -> pending_members(id) ON DELETE SET NULL, NULLABLE)
    - ADD CHECK constraint: `num_nonnulls(user_id, pending_member_id) = 1` (exactly one must be set)
    - DROP the existing unique constraint `expense_splits_expense_id_user_id_key`
    - CREATE partial unique index `expense_splits_expense_user_unique` on (expense_id, user_id) WHERE user_id IS NOT NULL
    - CREATE partial unique index `expense_splits_expense_pending_unique` on (expense_id, pending_member_id) WHERE pending_member_id IS NOT NULL
    - ADD index on pending_member_id WHERE pending_member_id IS NOT NULL

    IMPORTANT: The expense_splits RLS policy for SELECT joins expenses -> group_members. This still works because the RLS checks the group membership of the VIEWER, not the split target. No RLS changes needed for expense_splits.
  </action>
  <verify>
    Run `npx supabase db reset` (or push to a test project) and verify:
    1. pending_members table exists with correct columns
    2. expense_splits.user_id is nullable
    3. expense_splits.pending_member_id column exists
    4. CHECK constraint rejects rows where both user_id and pending_member_id are NULL
    5. CHECK constraint rejects rows where both are non-NULL
    If no local Supabase: verify SQL syntax by reading the files and confirming they reference correct table/column names from 00001_initial_schema.sql
  </verify>
  <done>
    pending_members table created with RLS. expense_splits supports pending_member_id with proper CHECK constraint and partial unique indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auto-link trigger and RPC functions</name>
  <files>
    supabase/migrations/00007_auto_link_trigger.sql
    supabase/migrations/00008_pending_member_rpcs.sql
  </files>
  <action>
    Create migration 00007_auto_link_trigger.sql:
    - Create function `public.handle_pending_member_claim()` as SECURITY DEFINER, language plpgsql, SET search_path = public
    - The function fires AFTER INSERT on auth.users
    - Logic: loop over all pending_members WHERE phone_number = NEW.phone
    - For each match:
      a. First ensure a public.users row exists: INSERT INTO public.users (id, phone_number) VALUES (NEW.id, NEW.phone) ON CONFLICT (id) DO NOTHING -- this is needed because public.users may not exist yet at trigger time (profile setup happens later). The phone_number column is NOT NULL so we must provide it.
      b. INSERT INTO group_members (group_id, user_id) VALUES (pending.group_id, NEW.id) ON CONFLICT (group_id, user_id) DO NOTHING
      c. UPDATE expense_splits SET user_id = NEW.id, pending_member_id = NULL WHERE pending_member_id = pending.id
      d. DELETE FROM pending_members WHERE id = pending.id
    - Wrap entire loop in BEGIN...EXCEPTION block: on error, RAISE WARNING (do NOT re-raise -- never block signups)
    - Create trigger: `CREATE TRIGGER on_auth_user_created_claim_pending AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_pending_member_claim()`

    CRITICAL: The trigger creates the public.users row with just id + phone_number (display_name will be NULL). The existing profile-setup screen does an UPSERT that fills in display_name later. This ordering is safe because:
    - group_members FK references public.users(id) -- needs the row to exist
    - Profile setup uses upsert (INSERT ON CONFLICT UPDATE) -- won't fail if row exists

    Create migration 00008_pending_member_rpcs.sql:
    - Create `add_pending_member(p_group_id uuid, p_phone_number text)` RETURNS uuid, SECURITY DEFINER, SET search_path = public
    - Logic:
      1. Verify caller is authenticated
      2. Verify caller is a member of the group
      3. Check if a user with this phone already exists in public.users: if yes AND already a group member, raise 'already a member'; if yes but NOT a group member, add them directly to group_members and return their user_id
      4. Check if phone is already pending in this group, raise if so
      5. Otherwise INSERT into pending_members, return the new pending member id
    - Replace `create_expense` RPC (CREATE OR REPLACE) to handle pending splits:
      - p_splits jsonb now accepts objects with either "user_id" or "pending_member_id" (one must be present)
      - Payer validation stays the same (must be real group member)
      - INSERT into expense_splits: parse each element, set user_id or pending_member_id accordingly (exactly one non-null)
      - Use: `CASE WHEN elem->>'user_id' IS NOT NULL AND elem->>'user_id' != '' THEN (elem->>'user_id')::uuid ELSE NULL END` pattern for user_id, and similar for pending_member_id
      - Existing expense creation with only user_id splits MUST still work (backward compatible)
  </action>
  <verify>
    Verify SQL syntax by reading all 4 migration files and confirming:
    1. handle_pending_member_claim references correct table names and column names
    2. add_pending_member RPC has proper auth checks
    3. Updated create_expense RPC is backward compatible (user_id-only splits still work)
    4. No syntax errors in PL/pgSQL blocks
    Run `npx supabase db reset` if local Supabase is available.
  </verify>
  <done>
    Auto-link trigger fires on auth.users INSERT and atomically claims pending members. add_pending_member RPC handles the full flow (existing user check, duplicate check, pending creation). create_expense RPC accepts pending_member_id in splits while remaining backward compatible.
  </done>
</task>

</tasks>

<verification>
All 4 migration files exist and contain valid SQL. The migrations can be applied in order (00005 -> 00006 -> 00007 -> 00008) without errors. The create_expense RPC still works for regular (non-pending) expense creation.
</verification>

<success_criteria>
- pending_members table exists with RLS policies
- expense_splits supports pending_member_id with CHECK constraint
- Auto-link trigger on auth.users INSERT
- add_pending_member and updated create_expense RPCs exist
- All migrations are syntactically valid and reference correct existing objects
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-pending-members-by-phone/04.1-01-SUMMARY.md`
</output>
