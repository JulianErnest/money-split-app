---
phase: 04-expenses
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/expense-utils.ts
  - lib/__tests__/expense-utils.test.ts
  - supabase/migrations/00004_create_expense_rpc.sql
  - lib/database.types.ts
autonomous: true

must_haves:
  truths:
    - "Equal split of 10000 centavos among 3 members sums to exactly 10000"
    - "Custom split remaining returns 0 when amounts match total"
    - "formatPeso displays Philippine peso format with 2 decimals"
    - "Amount cap at 99999900 centavos (999,999 pesos) is enforced"
    - "create_expense RPC function exists in database"
  artifacts:
    - path: "lib/expense-utils.ts"
      provides: "Pure split calculation and formatting functions"
      exports: ["calculateEqualSplit", "customSplitRemaining", "formatPeso", "pesosToCentavos", "centavosToPesos"]
    - path: "lib/__tests__/expense-utils.test.ts"
      provides: "Test coverage for expense math"
      min_lines: 40
    - path: "supabase/migrations/00004_create_expense_rpc.sql"
      provides: "Atomic create_expense RPC function"
      contains: "create or replace function"
  key_links:
    - from: "lib/expense-utils.ts"
      to: "centavo math"
      via: "integer arithmetic only"
      pattern: "Math\\.floor|Math\\.round"
---

<objective>
Build the expense math foundation: pure utility functions for split calculations and peso formatting (via TDD), plus the Supabase RPC migration for atomic expense creation.

Purpose: All expense features depend on correct currency math and atomic database writes. Getting these right first prevents cascading bugs in the wizard and list views.
Output: Tested expense-utils.ts, create_expense RPC migration, updated database types.
</objective>

<execution_context>
@/Users/julianernestcamello/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianernestcamello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-expenses/04-RESEARCH.md
@supabase/migrations/00003_group_rpc_functions.sql
@lib/database.types.ts
</context>

<feature>
  <name>Expense split calculations and formatting</name>
  <files>lib/expense-utils.ts, lib/__tests__/expense-utils.test.ts</files>
  <behavior>
    All currency math uses centavos (integers) to avoid floating-point errors.

    pesosToCentavos(100.50) -> 10050
    centavosToPesos(10050) -> 100.50
    formatPeso(10050) -> "100.50" (using Intl.NumberFormat('en-PH'))
    formatPeso(123456789) -> "1,234,567.89"

    calculateEqualSplit(10000, ['a','b','c']) -> { a: 3334, b: 3333, c: 3333 }
    calculateEqualSplit(100, ['a','b']) -> { a: 50, b: 50 }
    calculateEqualSplit(1, ['a','b','c']) -> { a: 1, b: 0, c: 0 }

    customSplitRemaining(10000, { a: 5000, b: 3000 }) -> 2000
    customSplitRemaining(10000, { a: 5000, b: 5000 }) -> 0
    customSplitRemaining(10000, {}) -> 10000

    MAX_AMOUNT_CENTAVOS = 99999900 (999,999.00 pesos)

    Edge cases:
    - Empty member array for equal split throws or returns empty
    - Remainder centavos distributed to first N members
    - Sum of all equal split values always equals the input total
  </behavior>
  <implementation>
    Create lib/expense-utils.ts with pure functions. Use Math.round for pesosToCentavos, Math.floor + remainder for equal splits.

    Test framework: Check if jest or vitest is configured in the project. If neither, install vitest (lightweight, works well with Expo). Write tests first (RED), implement (GREEN), refactor if needed.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: TDD expense utility functions</name>
  <files>lib/expense-utils.ts, lib/__tests__/expense-utils.test.ts, package.json</files>
  <action>
    1. Check if a test runner is already configured (look for jest.config or vitest.config in package.json). If not, install jest with ts-jest or use the expo jest preset if available (check if jest-expo is in devDependencies).

    2. RED: Create lib/__tests__/expense-utils.test.ts with tests for:
       - pesosToCentavos: converts peso float to centavo integer (100.50 -> 10050, 0 -> 0, 999999.99 -> 99999999)
       - centavosToPesos: converts centavos to peso float (10050 -> 100.50)
       - formatPeso: formats centavos to display string with Intl.NumberFormat('en-PH', { minimumFractionDigits: 2, maximumFractionDigits: 2 }). Test: 10050 -> "100.50", 123456789 -> "1,234,567.89", 0 -> "0.00"
       - calculateEqualSplit: test that splits sum to total (10000/3, 100/2, 1/3, 10001/4). Test remainder distribution.
       - customSplitRemaining: test exact match returns 0, partial returns remainder, empty returns total
       - MAX_AMOUNT_CENTAVOS exported as 99999900

    3. Run tests -- they MUST fail (no implementation yet).

    4. GREEN: Create lib/expense-utils.ts implementing all functions:
       - pesosToCentavos(pesos: number): number -- Math.round(pesos * 100)
       - centavosToPesos(centavos: number): number -- centavos / 100
       - formatPeso(centavos: number): string -- Intl.NumberFormat on centavos/100
       - calculateEqualSplit(totalCentavos: number, memberIds: string[]): Record<string, number> -- Math.floor + remainder to first N
       - customSplitRemaining(totalCentavos: number, amounts: Record<string, number>): number -- total minus sum
       - Export MAX_AMOUNT_CENTAVOS = 99999900

    5. Run tests -- they MUST pass.

    6. REFACTOR only if there's an obvious cleanup.
  </action>
  <verify>Test command passes with all tests green. Verify: sum of calculateEqualSplit always equals input total across all test cases.</verify>
  <done>All expense utility functions exist with passing tests. pesosToCentavos, centavosToPesos, formatPeso, calculateEqualSplit, customSplitRemaining, MAX_AMOUNT_CENTAVOS are exported.</done>
</task>

<task type="auto">
  <name>Task 2: Supabase create_expense RPC migration and types</name>
  <files>supabase/migrations/00004_create_expense_rpc.sql, lib/database.types.ts</files>
  <action>
    1. Create supabase/migrations/00004_create_expense_rpc.sql following the pattern in 00003_group_rpc_functions.sql (security definer, set search_path = public).

    The function signature:
    ```sql
    create or replace function public.create_expense(
      p_group_id uuid,
      p_description text,
      p_amount numeric(10,2),
      p_paid_by uuid,
      p_split_type text,
      p_splits jsonb  -- array of { user_id: uuid, amount: numeric }
    ) returns uuid
    language plpgsql
    security definer
    set search_path = public
    ```

    Function body must:
    - Check auth.uid() is not null (raise 'Not authenticated')
    - Verify caller is a member of the group (query group_members)
    - Verify p_paid_by is a member of the group
    - Validate split amounts sum to p_amount (iterate jsonb_array_elements, accumulate total, raise if mismatch)
    - Validate p_split_type is 'equal' or 'custom'
    - Insert into expenses table (group_id, description, amount, paid_by, split_type, created_by = auth.uid())
    - Insert into expense_splits from jsonb array (expense_id, user_id, amount)
    - Return the new expense id

    2. Update lib/database.types.ts: Add the create_expense function signature to the Functions interface inside the Database type. Follow the pattern of any existing RPC functions in the file. Add:
    ```typescript
    create_expense: {
      Args: {
        p_group_id: string
        p_description: string
        p_amount: number
        p_paid_by: string
        p_split_type: string
        p_splits: Json
      }
      Returns: string
    }
    ```

    IMPORTANT: Read the existing database.types.ts structure first to place the function type in the correct location within the type hierarchy.
  </action>
  <verify>SQL file has valid syntax (no obvious errors). database.types.ts includes create_expense in Functions. Run `npx tsc --noEmit` to verify no TypeScript errors.</verify>
  <done>Migration file 00004 exists with atomic create_expense function. database.types.ts includes the RPC type signature. TypeScript compiles clean.</done>
</task>

</tasks>

<verification>
- All expense-utils tests pass
- TypeScript compiles without errors
- Migration file 00004 exists with create_expense RPC
- database.types.ts has create_expense function type
</verification>

<success_criteria>
- calculateEqualSplit(10000, ['a','b','c']) returns splits summing to exactly 10000
- formatPeso(10050) returns "100.50"
- customSplitRemaining returns 0 for exact match
- create_expense RPC validates group membership, split sum, and inserts atomically
</success_criteria>

<output>
After completion, create `.planning/phases/04-expenses/04-01-SUMMARY.md`
</output>
