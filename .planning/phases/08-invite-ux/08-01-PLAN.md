---
phase: 08-invite-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00020_invite_accept_decline.sql
  - lib/database.types.ts
autonomous: true

must_haves:
  truths:
    - "get_my_pending_invites RPC returns pending invites for the authenticated user with group name and inviter name"
    - "accept_invite RPC adds user to group_members, transfers expense splits, and deletes the pending_members row"
    - "decline_invite RPC deletes expense splits for the pending member and hard-deletes the pending_members row"
    - "An invited user can SELECT their own pending_members rows via RLS (user_id = auth.uid())"
  artifacts:
    - path: "supabase/migrations/00020_invite_accept_decline.sql"
      provides: "Three security definer RPCs and one RLS policy"
      contains: "get_my_pending_invites|accept_invite|decline_invite"
    - path: "lib/database.types.ts"
      provides: "TypeScript types for the three new RPCs"
      contains: "accept_invite|decline_invite|get_my_pending_invites"
  key_links:
    - from: "accept_invite RPC"
      to: "group_members, expense_splits, pending_members tables"
      via: "INSERT group_members, UPDATE expense_splits SET user_id + pending_member_id=NULL, DELETE pending_members"
      pattern: "insert into group_members.*on conflict.*do nothing"
    - from: "decline_invite RPC"
      to: "expense_splits, pending_members tables"
      via: "DELETE expense_splits WHERE pending_member_id, DELETE pending_members"
      pattern: "delete from expense_splits.*where pending_member_id"
---

<objective>
Create the three Supabase RPCs (`get_my_pending_invites`, `accept_invite`, `decline_invite`) and a new RLS policy that allows invited users to see their own pending invite rows.

Purpose: The invite UI (Plan 08-02) needs server-side operations to fetch, accept, and decline invites. These RPCs must be security definer functions because they cross multiple tables with RLS restrictions that would block direct client operations.

Output: Migration 00020 with three RPCs and one RLS policy; updated TypeScript types in database.types.ts.
</objective>

<execution_context>
@/Users/julianernestcamello/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianernestcamello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-invite-ux/08-RESEARCH.md
@supabase/migrations/00019_invite_status_consent_flow.sql
@supabase/migrations/00016_remove_group_member.sql
@supabase/migrations/00003_group_rpc_functions.sql
@lib/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 00020 with invite RPCs and RLS policy</name>
  <files>supabase/migrations/00020_invite_accept_decline.sql</files>
  <action>
Create `supabase/migrations/00020_invite_accept_decline.sql` with four parts:

**Part 1 -- RLS policy for invite inbox SELECT:**
Add a new SELECT policy on `pending_members`:
```sql
create policy "Users can view their own pending invites"
  on public.pending_members for select
  using (user_id = (select auth.uid()));
```
This allows an invited user to see their own pending_members rows even though they are not yet in group_members. The existing policy for group members viewing pending_members remains unchanged.

**Part 2 -- get_my_pending_invites RPC:**
Security definer function returning `table(pending_member_id uuid, group_id uuid, group_name text, invited_by_name text)`.
- Verify `auth.uid()` is not null
- Query `pending_members pm JOIN groups g ON g.id = pm.group_id JOIN users u ON u.id = pm.added_by`
- Filter: `pm.user_id = current_user_id AND pm.invite_status = 'pending'`
- Use `coalesce(u.display_name, 'Someone')` for invited_by_name
- Follow the pattern from `get_my_group_balances` in migration 00009

**Part 3 -- accept_invite RPC:**
Security definer function: `accept_invite(p_pending_member_id uuid) returns uuid`.
Steps (all inside a single transaction):
1. Fetch `group_id, user_id, invite_status` from `pending_members WHERE id = p_pending_member_id`
2. Validate: row exists, `user_id = auth.uid()`, `invite_status = 'pending'`
3. `INSERT INTO group_members (group_id, user_id) VALUES (v_group_id, current_user_id) ON CONFLICT (group_id, user_id) DO NOTHING` -- idempotent, handles edge case where user joined via link while invite was pending
4. `UPDATE expense_splits SET user_id = current_user_id, pending_member_id = NULL WHERE pending_member_id = p_pending_member_id` -- single statement satisfies the `expense_splits_member_check` constraint
5. `DELETE FROM pending_members WHERE id = p_pending_member_id` -- hard delete
6. Return `v_group_id` for client-side navigation

Error messages: 'Not authenticated', 'Invite not found', 'This invite is not for you', 'This invite has already been [status]'

**Part 4 -- decline_invite RPC:**
Security definer function: `decline_invite(p_pending_member_id uuid) returns void`.
Steps:
1. Fetch `user_id, invite_status` from `pending_members WHERE id = p_pending_member_id`
2. Validate: row exists, `user_id = auth.uid()`, `invite_status = 'pending'`
3. `DELETE FROM expense_splits WHERE pending_member_id = p_pending_member_id` -- removes all splits for this pending member so balances recalculate (INV-07)
4. `DELETE FROM pending_members WHERE id = p_pending_member_id` -- hard delete allows re-invite by creator later

Error messages: same validation pattern as accept_invite.

All three functions use: `language plpgsql`, `security definer`, `set search_path = public`, `set row_security = off`. Follow the exact pattern from migrations 00003 and 00019.
  </action>
  <verify>
Run: `grep -c 'create or replace function' supabase/migrations/00020_invite_accept_decline.sql` -- should return 3.
Run: `grep -c 'create policy' supabase/migrations/00020_invite_accept_decline.sql` -- should return 1.
Verify SQL is syntactically valid by checking: no unmatched BEGIN/END blocks, all statements end with semicolons, proper $$ delimiters.
  </verify>
  <done>
Migration 00020 exists with: (1) RLS policy allowing user_id-based SELECT on pending_members, (2) get_my_pending_invites returning denormalized invite data, (3) accept_invite that atomically adds to group + transfers splits + deletes pending row + returns group_id, (4) decline_invite that deletes splits and pending row (hard delete for re-invite support).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add new RPC type signatures to database.types.ts</name>
  <files>lib/database.types.ts</files>
  <action>
Add three new function type entries to the `Functions` section of `lib/database.types.ts`, after the existing `get_my_group_balances` entry:

```typescript
accept_invite: {
  Args: { p_pending_member_id: string };
  Returns: string;  // group_id UUID
};
decline_invite: {
  Args: { p_pending_member_id: string };
  Returns: undefined;  // void
};
get_my_pending_invites: {
  Args: Record<string, never>;
  Returns: Array<{
    pending_member_id: string;
    group_id: string;
    group_name: string;
    invited_by_name: string;
  }>;
};
```

Follow the exact style of existing entries (2-space indent, semicolons, same type patterns). Place them alphabetically or grouped logically after the existing function definitions.
  </action>
  <verify>
Run: `npx expo export --platform ios 2>&1 | tail -5` -- should compile without TypeScript errors.
Verify the three function names appear in `lib/database.types.ts`: `grep -c 'accept_invite\|decline_invite\|get_my_pending_invites' lib/database.types.ts` -- should return 3 (one per function key).
  </verify>
  <done>
database.types.ts contains type definitions for accept_invite (Args: p_pending_member_id, Returns: string), decline_invite (Args: p_pending_member_id, Returns: undefined), and get_my_pending_invites (Args: none, Returns: array of invite rows). App compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. Migration 00020 contains exactly 3 `create or replace function` statements and 1 `create policy` statement
2. accept_invite uses `ON CONFLICT (group_id, user_id) DO NOTHING` for idempotent group membership
3. accept_invite transfers expense_splits with single UPDATE (SET user_id + pending_member_id = NULL) to satisfy check constraint
4. decline_invite hard-deletes both expense_splits and pending_members (not soft delete)
5. get_my_pending_invites joins pending_members -> groups -> users for denormalized output
6. All three RPCs validate auth.uid() matches pending_members.user_id
7. database.types.ts has all three function signatures
8. App compiles without TypeScript errors
</verification>

<success_criteria>
- Three security definer RPCs exist in migration 00020, each with proper auth validation
- RLS policy allows invited users to SELECT their own pending_members rows
- accept_invite returns group_id for navigation, handles duplicate group_members gracefully
- decline_invite hard-deletes pending_members row (allows re-invite)
- database.types.ts updated with matching function signatures
- `npx expo export --platform ios` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-invite-ux/08-01-SUMMARY.md`
</output>
