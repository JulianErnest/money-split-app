---
phase: 06-polish-distribution
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - lib/sync-manager.ts
  - components/ui/Toast.tsx
  - app/(tabs)/index.tsx
  - app/group/[id]/add-expense.tsx
  - app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a group while offline and it appears in the list with a pending indicator"
    - "User can add an expense while offline and it appears in the group with a pending indicator"
    - "When connectivity returns, queued actions sync automatically and pending indicators disappear"
    - "If sync fails on reconnect, user sees an error toast with a Retry button"
    - "User controls retry -- no silent auto-retry loop"
  artifacts:
    - path: "lib/sync-manager.ts"
      provides: "Sync flush hook that watches isOnline and flushes offline queue"
      contains: "useSyncOnReconnect"
    - path: "components/ui/Toast.tsx"
      provides: "Toast/snackbar component with action button support"
      contains: "Retry"
  key_links:
    - from: "lib/sync-manager.ts"
      to: "lib/network-context.tsx"
      via: "useNetwork().isOnline triggers flush"
      pattern: "isOnline"
    - from: "lib/sync-manager.ts"
      to: "lib/offline-queue.ts"
      via: "getAll() and remove() to process queue"
      pattern: "getAll|remove"
    - from: "lib/sync-manager.ts"
      to: "lib/supabase.ts"
      via: "supabase.rpc calls to replay queued actions"
      pattern: "supabase\\.rpc"
    - from: "app/(tabs)/index.tsx"
      to: "lib/offline-queue.ts"
      via: "enqueue('create_group', payload) when !isOnline"
      pattern: "enqueue"
    - from: "app/group/[id]/add-expense.tsx"
      to: "lib/offline-queue.ts"
      via: "enqueue('add_expense', payload) when !isOnline"
      pattern: "enqueue"
    - from: "lib/sync-manager.ts"
      to: "components/ui/Toast.tsx"
      via: "showToast on sync failure with Retry action"
      pattern: "showToast|Toast"
---

<objective>
Wire the offline behavioral layer: make screens enqueue actions when offline with optimistic pending state, create the sync-on-reconnect loop that flushes the queue when connectivity returns, and build an error toast with Retry button for sync failures.

Purpose: The offline infrastructure (queue, network context, cached data) was built in Plan 01, but nothing uses it yet. This plan connects the plumbing to actual user flows so offline actions work end-to-end.
Output: Create-group and add-expense work offline with pending indicators. Reconnect triggers automatic sync. Failures show error toast with Retry.
</objective>

<execution_context>
@/Users/julianernestcamello/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianernestcamello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-distribution/06-RESEARCH.md
@.planning/phases/06-polish-distribution/06-01-SUMMARY.md
@.planning/phases/06-polish-distribution/06-02-SUMMARY.md
@lib/offline-queue.ts
@lib/network-context.tsx
@lib/supabase.ts
@app/(tabs)/index.tsx
@app/group/[id]/add-expense.tsx
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync manager and toast component</name>
  <files>
    lib/sync-manager.ts
    components/ui/Toast.tsx
  </files>
  <action>
1. Create `components/ui/Toast.tsx`:
   - Build a simple toast/snackbar component using Reanimated for enter/exit animation
   - Props: `{ message: string, type: 'error' | 'success' | 'info', actionLabel?: string, onAction?: () => void, visible: boolean, onDismiss: () => void }`
   - Position: fixed at bottom of screen above safe area
   - Style: rounded rectangle, `backgroundColor: colors.error` for error type, `colors.success` for success, `colors.surface` for info
   - When `actionLabel` provided, show a pressable text button on the right side (e.g., "Retry" in bold)
   - Auto-dismiss after 5 seconds unless actionLabel is provided (persistent until user acts or dismisses)
   - Animation: slide up from bottom (entering: SlideInDown, exiting: SlideOutDown)
   - Also export a `ToastProvider` and `useToast()` hook:
     - `ToastProvider` manages toast state and renders the Toast component
     - `useToast()` returns `{ showToast: (opts: { message, type, actionLabel?, onAction? }) => void }`
     - Only one toast visible at a time (new toast replaces old)

2. Create `lib/sync-manager.ts`:
   - Export a `useSyncOnReconnect` hook that accepts an optional `onSyncComplete?: () => void` callback:
     a) Imports `useNetwork` from `@/lib/network-context`
     b) Imports `getAll`, `remove`, `updateStatus` from `@/lib/offline-queue`
     c) Imports `supabase` from `@/lib/supabase`
     d) Imports `useToast` from `@/components/ui/Toast`
     e) Uses a `useRef` to track previous isOnline value (prevOnlineRef)
     f) In a `useEffect` watching `isOnline`:
        - If `prevOnlineRef.current === false && isOnline === true` (just came back online):
          - Call `flushQueue()` async function
        - Update `prevOnlineRef.current = isOnline`
     g) `flushQueue()` implementation:
        - Get all pending items via `getAll()`
        - If empty, call `onSyncComplete?.()` and return early
        - For each item, attempt to replay the action:
          - If `action_type === 'create_group'`: call `supabase.rpc('create_group', { group_name: payload.group_name })`
          - If `action_type === 'add_expense'`: call `supabase.rpc('create_expense', payload.rpcParams)`
        - On success for an item: call `remove(item.id)`
        - On failure for an item: call `updateStatus(item.id, 'failed')` and show error toast:
          `showToast({ message: 'Sync failed for "{description}". Tap to retry.', type: 'error', actionLabel: 'Retry', onAction: () => retrySingleItem(item) })`
        - `retrySingleItem`: same logic as above but for a single item
        - After processing ALL items (whether success or partial failure), call `onSyncComplete?.()` so the calling component can trigger a re-fetch/re-render to clear pending indicators from UI state
     h) IMPORTANT: No silent auto-retry loop. The flush runs once on reconnect. If it fails, user sees the toast and controls retry via the Retry button. Per locked decision: "No silent auto-retry -- user controls retry."
   - Export `useSyncOnReconnect` to be called in the root layout or a top-level component
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Toast component renders with message and action button
    - sync-manager exports useSyncOnReconnect hook with onSyncComplete callback
  </verify>
  <done>
    - Toast.tsx exports ToastProvider, useToast with support for error toasts with Retry action button
    - sync-manager.ts exports useSyncOnReconnect that flushes queue on reconnect, shows error toast on failure, calls onSyncComplete callback after flush
    - No auto-retry loop -- single flush attempt, user controls retry via toast button
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire offline enqueue with optimistic state into screens</name>
  <files>
    app/(tabs)/index.tsx
    app/group/[id]/add-expense.tsx
    app/_layout.tsx
  </files>
  <action>
1. Update `app/_layout.tsx`:
   - Import `ToastProvider` from `@/components/ui/Toast`
   - Wrap app content with `ToastProvider` inside NetworkProvider (so toast can be shown from anywhere)
   - Import `useSyncOnReconnect` from `@/lib/sync-manager`
   - Create a `SyncWatcher` component that calls `useSyncOnReconnect` with an `onSyncComplete` callback. The callback should increment a global sync counter (using a simple React context or exported event emitter) that screens can subscribe to for re-fetching:
     ```tsx
     function SyncWatcher() {
       useSyncOnReconnect({
         onSyncComplete: () => {
           // Trigger re-fetch signal for screens showing pending items.
           // The groups screen (index.tsx) uses useFocusEffect which re-fetches
           // on focus, but if the user is CURRENTLY on the groups screen,
           // we need an explicit signal. Use a simple exported callback ref
           // or event that index.tsx subscribes to.
         }
       });
       return null;
     }
     ```
     Place `<SyncWatcher />` inside the providers.
   - For the re-fetch mechanism: the simplest approach is to have SyncWatcher call `router.replace` to the current route (forcing a re-render), OR export a `syncCompleteListeners` Set from sync-manager that screens can subscribe to. Choose the listener approach for cleanliness.

2. Update `app/(tabs)/index.tsx` (create group offline flow):
   - Import `useNetwork` from `@/lib/network-context`
   - Import `enqueue` from `@/lib/offline-queue`
   - In `handleCreateGroup`, before the Supabase RPC call, check `isOnline`:
     - If `!isOnline`:
       a) Call `enqueue('create_group', { group_name: trimmed })`
       b) Optimistically add the group to local state with a `pending: true` flag:
          - Add to the groups array: `{ id: 'pending_' + Date.now(), name: trimmed, member_count: 1, pending: true }`
          - This makes it appear in the list immediately
       c) Close the create group sheet/modal
       d) Show haptic success feedback
       e) Skip the Supabase RPC call entirely (it will be replayed by sync-manager on reconnect)
     - If `isOnline`: proceed with existing Supabase RPC call as before
   - Render pending indicator on groups with `pending: true`:
     - Add a small badge or opacity change (e.g., `opacity: 0.6` + small "Pending" text or clock icon) on the group card
     - Per locked decision: "Show items optimistically (with pending state)"
   - Subscribe to sync-complete signal: when sync completes, filter out pending items from local state and call `fetchGroups()` to get the real data from Supabase. This ensures pending indicators disappear and are replaced with synced data.
   - Note: `useFocusEffect` already re-fetches on screen focus, which handles the case where user navigates away and back. But for the case where user is ON the groups screen when sync completes, the explicit listener is needed.

3. Update `app/group/[id]/add-expense.tsx` (add expense offline flow):
   - Import `useNetwork` from `@/lib/network-context`
   - Import `enqueue` from `@/lib/offline-queue`
   - Find the `supabase.rpc("create_expense", ...)` call in the submit handler
   - Before calling the RPC, check `isOnline`:
     - If `!isOnline`:
       a) Build the RPC params object (same shape as what's passed to `supabase.rpc("create_expense", ...)`)
       b) Call `enqueue('add_expense', { rpcParams: rpcParams, description: description.trim(), amount: centavos / 100 })`
       c) Show success haptic and navigate back (as if it succeeded)
       d) The expense will appear as pending when the group detail screen refreshes
       e) Skip the actual Supabase RPC call
     - If `isOnline`: proceed with existing Supabase RPC call as before
   - Note: The pending expense visibility in group detail will be handled by the sync manager removing it from queue on successful sync and the group detail re-fetching data. For the optimistic case, the add-expense screen navigates back and the group detail will show its last cached data plus the user knows they queued an action.

4. IMPORTANT per locked decisions:
   - "Show items optimistically (with pending state)" -- groups must show pending indicator
   - "On reconnect sync failure: show error toast with a Retry action button" -- handled by sync-manager
   - "Item stays in pending until resolved" -- pending items remain until sync succeeds or user retries
   - "No silent auto-retry" -- flush runs once, user controls retry via toast
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - With airplane mode ON: create a group -> group appears in list with pending indicator
    - With airplane mode ON: add an expense -> navigates back successfully
    - Turn airplane mode OFF: queued actions sync and pending indicators disappear (groups screen re-fetches after sync)
    - If sync fails (e.g., invalid data): error toast appears with Retry button
  </verify>
  <done>
    - Create group works offline: enqueues action, shows group optimistically with pending indicator
    - Add expense works offline: enqueues action, navigates back as if succeeded
    - SyncWatcher in root layout flushes queue when connectivity returns
    - After sync completes (success or partial), onSyncComplete callback fires, triggering screens to re-fetch and clear pending indicators
    - Sync failure shows error toast with Retry action button
    - No silent auto-retry loop
    - ToastProvider wired into root layout
  </done>
</task>

</tasks>

<verification>
1. Airplane mode ON -> create group -> appears in list with pending indicator
2. Airplane mode ON -> add expense -> navigates back, action queued
3. Airplane mode OFF -> pending items sync automatically, pending indicators disappear as screens re-fetch
4. Force a sync failure (e.g., create group with duplicate name) -> error toast with Retry button appears
5. Tap Retry -> retries the failed item
6. `npx tsc --noEmit` passes
7. No auto-retry loops running in background
</verification>

<success_criteria>
- Offline create-group and add-expense work end-to-end with optimistic pending state
- Reconnect triggers one-time queue flush
- After flush, onSyncComplete fires and screens re-fetch to clear pending indicators
- Sync failures show error toast with Retry action button
- User controls retry (no silent auto-retry)
- Pending items stay pending until resolved
- All wiring connects Plan 01 infrastructure to actual screens
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-distribution/06-05-SUMMARY.md`
</output>
